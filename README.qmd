---
title: "README"
format: gfm
---

## FastAPI, Jinja2, PostgreSQL Webapp

![Screenshot of homepage](static/Screenshot.png)

This project is still under development.

### Architecture

This application uses a Post-Redirect-Get (PRG) pattern. The user submits a form, which sends a POST request to a FastAPI endpoint on the server. The database is updated, and the user is redirected to a GET endpoint, which fetches the updated data and re-renders the Jinja2 page template with the new data.

``` {python}
#| echo: false
#| include: false
from graphviz import Digraph

dot = Digraph()

dot.node('A', 'User submits form')
dot.node('B', 'HTML/JS form validation')
dot.node('C', 'Convert to Pydantic model')
dot.node('D', 'Optional custom validation')
dot.node('E', 'Update database')
dot.node('F', 'Middleware error handler')
dot.node('G', 'Render error template')
dot.node('H', 'Redirect to GET endpoint')
dot.node('I', 'Fetch updated data')
dot.node('J', 'Re-render Jinja2 page template')

dot.edge('A', 'B')
dot.edge('B', 'A')
dot.edge('B', 'C', label='POST Request to FastAPI endpoint')
dot.edge('C', 'D')
dot.edge('C', 'F', label='RequestValidationError')
dot.edge('D', 'E', label='Valid data')
dot.edge('D', 'F', label='Custom Validation Error')
dot.edge('E', 'H', label='Data updated')
dot.edge('H', 'I')
dot.edge('I', 'J')
dot.edge('F', 'G')

dot.render('static/webapp_flow', format='png', cleanup=True)
```

![Webapp Flow](static/webapp_flow.png)

The advantage of the PRG pattern is that it is very straightforward to implement and keeps most of the rendering logic on the server side. The disadvantage is that it requires an extra round trip to the database to fetch the updated data, and re-rendering the entire page template may be less efficient than a partial page update on the client side.

### Authentication Flow

This application implements a comprehensive authentication system with security best practices. The diagrams below show the main authentication flows and security measures.

#### Registration and Login Flow

``` {python}
#| echo: false
#| include: false
from graphviz import Digraph

# Create graph for registration/login
auth = Digraph(name='auth_flow')
auth.attr(rankdir='TB')
auth.attr('node', shape='box', style='rounded')

# Client-side nodes
with auth.subgraph(name='cluster_client') as client:
    client.attr(label='Client')
    client.node('register_form', 'Submit registration')
    client.node('login_form', 'Submit login')
    client.node('store_cookies', 'Store secure cookies')

# Server-side nodes
with auth.subgraph(name='cluster_server') as server:
    server.attr(label='Server')
    # Registration path
    server.node('validate_register', 'Validate registration data')
    server.node('hash_new', 'Hash new password')
    server.node('store_user', 'Store user in database')
    
    # Login path
    server.node('validate_login', 'Validate login data')
    server.node('verify_password', 'Verify password hash')
    server.node('fetch_user', 'Fetch user from database')
    
    # Common path
    server.node('generate_tokens', 'Generate JWT tokens')

# Registration path
auth.edge('register_form', 'validate_register', 'POST /register')
auth.edge('validate_register', 'hash_new')
auth.edge('hash_new', 'store_user')
auth.edge('store_user', 'generate_tokens', 'Success')

# Login path
auth.edge('login_form', 'validate_login', 'POST /login')
auth.edge('validate_login', 'fetch_user')
auth.edge('fetch_user', 'verify_password')
auth.edge('verify_password', 'generate_tokens', 'Success')

# Common path
auth.edge('generate_tokens', 'store_cookies', 'Set-Cookie')

auth.render('static/auth_flow', format='png', cleanup=True)
```

![Registration and Login Flow](static/auth_flow.png)

#### Password Reset Flow

``` {python}
#| echo: false
#| include: false
from graphviz import Digraph

# Create graph for password reset
reset = Digraph(name='reset_flow')
reset.attr(rankdir='TB')
reset.attr('node', shape='box', style='rounded')

# Client-side nodes
reset.attr(label='Client')
reset.node('forgot', 'User submits forgot password form')
reset.node('reset', 'User submits reset password form')
reset.node('email_client', 'User clicks reset link')

# Server-side nodes
reset.attr(label='Server')
reset.node('validate', 'Validation')
reset.node('token_gen', 'Generate reset token')
reset.node('hash', 'Hash password')
reset.node('email_server', 'Send email with Resend')
reset.node('db', 'Database', shape='cylinder')

# Add edges with labels
reset.edge('forgot', 'token_gen', 'POST')
reset.edge('token_gen', 'db', 'Store')
reset.edge('token_gen', 'email_server', 'Add email/token as URL parameter')
reset.edge('email_server', 'email_client')
reset.edge('email_client', 'reset', 'Set email/token as form input')
reset.edge('reset', 'validate', 'POST')
reset.edge('validate', 'hash')
reset.edge('hash', 'db', 'Update')

reset.render('static/reset_flow', format='png', cleanup=True)
```

![Password Reset Flow](static/reset_flow.png)

The authentication system implements multiple security measures:

1. **Token Security**:
   - JWT-based with separate access/refresh tokens
   - Strict expiry times (30 min access, 30 day refresh)
   - Token type validation
   - HTTP-only cookies
   - Secure flag enabled
   - SameSite=strict restriction

2. **Password Security**:
   - Strong password requirements enforced
   - Bcrypt hashing with random salt
   - Password reset tokens are single-use
   - Reset tokens have expiration

3. **Cookie Security**:
   - HTTP-only prevents JavaScript access
   - Secure flag ensures HTTPS only
   - Strict SameSite prevents CSRF

4. **Error Handling**:
   - Validation errors properly handled
   - Security-related errors don't leak information
   - Comprehensive error logging

### Install development dependencies in a VSCode Dev Container

If you use VSCode with Docker to develop in a container, the following VSCode Dev Container configuration will install all dependencies:

``` json
{
	"name": "Python 3",
	"image": "mcr.microsoft.com/devcontainers/python:1-3.12-bullseye",
	"postCreateCommand": "sudo apt update && sudo apt install -y python3-dev libpq-dev graphviz && pipx install poetry && poetry install && poetry shell",
	"features": {
		"ghcr.io/devcontainers/features/docker-outside-of-docker:1": {},
		"ghcr.io/rocker-org/devcontainer-features/quarto-cli:1": {}
	}
}
```

Simply create a `.devcontainer` folder in the root of the project and add a `devcontainer.json` file in the folder with the above content. VSCode may prompt you to install the Dev Container extension if you haven't already, and/or to open the project in a container. If not, you can manually select "Dev Containers: Reopen in Container" from View > Command Palette.

### Install development dependencies manually

#### Python and Docker

- [Python 3.12 or higher](https://www.python.org/downloads/)
- [Docker and Docker Compose](https://docs.docker.com/get-docker/)

#### PostgreSQL headers

For Ubuntu/Debian:

``` bash
sudo apt update && sudo apt install -y python3-dev libpq-dev
```

For macOS:

``` bash
brew install postgresql
```

For Windows:

- No installation required

#### Quarto CLI and Graphviz

- [Quarto CLI](https://quarto.org/docs/get-started/)


For macOS:

``` bash
brew install graphviz
```

For Ubuntu/Debian:

``` bash
sudo apt update && sudo apt install -y graphviz
```

For Windows:

- Download and install from [Graphviz.org](https://graphviz.org/download/#windows)

#### Python dependencies

1.  Install Poetry

``` bash
pipx install poetry
```

2.  Install project dependencies

``` bash
poetry install
```

3.  Activate shell

``` bash
poetry shell
```

(Note: You will need to activate the shell every time you open a new terminal session. Alternatively, you can use the `poetry run` prefix before other commands to run them without activating the shell.)

### Set environment variables

Copy .env.example to .env with `cp .env.example .env`.

Generate a 256 bit secret key with `openssl rand -base64 32` and paste it into the .env file.

Set your desired database name, username, and password in the .env file.

To use password recovery, register a [Resend](https://resend.com/) account, verify a domain, get an API key, and paste the API key into the .env file.

### Start development database

``` bash
docker compose up -d
```

### Run the development server

Make sure the development database is running and tables and default permissions/roles are created first.

``` bash
uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```

Navigate to http://localhost:8000/

### Lint types with mypy

``` bash
mypy .
```

### Render the README

When updating the documentation, remember to make changes in the README.qmd file, not the README.md file. Then run the following command to render the README.md file:

``` bash
quarto render README.qmd
```

### Contributing

Fork the repository, create a new branch, make your changes, and submit a pull request.

### License

This project is licensed under the MIT License. See the LICENSE file for more details.
