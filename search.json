[
  {
    "objectID": "docs/architecture.html",
    "href": "docs/architecture.html",
    "title": "Architecture",
    "section": "",
    "text": "This application uses a Post-Redirect-Get (PRG) pattern. The user submits a form, which sends a POST request to a FastAPI endpoint on the server. The database is updated, and the user is redirected to a GET endpoint, which fetches the updated data and re-renders the Jinja2 page template with the new data.\n\n\n\nData flow diagram\n\n\nThe advantage of the PRG pattern is that it is very straightforward to implement and keeps most of the rendering logic on the server side. One disadvantage is that it requires an extra round trip to the database to fetch the updated data, and re-rendering the entire page template may be less efficient than a partial page update on the client side. Another disadvantage is that it if the user makes an invalid form submission, they will see an error page and will have to click the browser’s “back” button to get back to the form with their original form inputs.\nA future iteration of this application will use HTMX to update the page in place, so that on an invalid submission an error toast is displayed without a page reload (thus preserving the user’s scroll position and form inputs)."
  },
  {
    "objectID": "docs/architecture.html#data-flow",
    "href": "docs/architecture.html#data-flow",
    "title": "Architecture",
    "section": "",
    "text": "This application uses a Post-Redirect-Get (PRG) pattern. The user submits a form, which sends a POST request to a FastAPI endpoint on the server. The database is updated, and the user is redirected to a GET endpoint, which fetches the updated data and re-renders the Jinja2 page template with the new data.\n\n\n\nData flow diagram\n\n\nThe advantage of the PRG pattern is that it is very straightforward to implement and keeps most of the rendering logic on the server side. One disadvantage is that it requires an extra round trip to the database to fetch the updated data, and re-rendering the entire page template may be less efficient than a partial page update on the client side. Another disadvantage is that it if the user makes an invalid form submission, they will see an error page and will have to click the browser’s “back” button to get back to the form with their original form inputs.\nA future iteration of this application will use HTMX to update the page in place, so that on an invalid submission an error toast is displayed without a page reload (thus preserving the user’s scroll position and form inputs)."
  },
  {
    "objectID": "docs/installation.html",
    "href": "docs/installation.html",
    "title": "Installation",
    "section": "",
    "text": "If you use VSCode with Docker to develop in a container, the following VSCode Dev Container configuration will install all development dependencies:\n{\n    \"name\": \"Python 3\",\n    \"image\": \"mcr.microsoft.com/devcontainers/python:1-3.12-bookworm\",\n    \"postCreateCommand\": \"sudo apt update && sudo apt install -y python3-dev libpq-dev graphviz libwebp-dev && npm install bootstrap@5.3.3 && npm install -g sass && npm install -g gulp && uv venv && uv sync\",\n    \"features\": {\n        \"ghcr.io/va-h/devcontainers-features/uv:1\": {\n            \"version\": \"latest\"\n        },\n        \"ghcr.io/devcontainers/features/docker-outside-of-docker:1\": {},\n        \"ghcr.io/rocker-org/devcontainer-features/quarto-cli:1\": {}\n    }\n}\nSimply create a .devcontainer folder in the root of the project and add a devcontainer.json file in the folder with the above content. VSCode may prompt you to install the Dev Container extension if you haven’t already, and/or to open the project in a container. If not, you can manually select “Dev Containers: Reopen in Container” from View &gt; Command Palette.\nIMPORTANT: If using this dev container configuration, you will need to set the DB_HOST environment variable to “host.docker.internal” in the .env file."
  },
  {
    "objectID": "docs/installation.html#install-all-development-dependencies-in-a-vscode-dev-container",
    "href": "docs/installation.html#install-all-development-dependencies-in-a-vscode-dev-container",
    "title": "Installation",
    "section": "",
    "text": "If you use VSCode with Docker to develop in a container, the following VSCode Dev Container configuration will install all development dependencies:\n{\n    \"name\": \"Python 3\",\n    \"image\": \"mcr.microsoft.com/devcontainers/python:1-3.12-bookworm\",\n    \"postCreateCommand\": \"sudo apt update && sudo apt install -y python3-dev libpq-dev graphviz libwebp-dev && npm install bootstrap@5.3.3 && npm install -g sass && npm install -g gulp && uv venv && uv sync\",\n    \"features\": {\n        \"ghcr.io/va-h/devcontainers-features/uv:1\": {\n            \"version\": \"latest\"\n        },\n        \"ghcr.io/devcontainers/features/docker-outside-of-docker:1\": {},\n        \"ghcr.io/rocker-org/devcontainer-features/quarto-cli:1\": {}\n    }\n}\nSimply create a .devcontainer folder in the root of the project and add a devcontainer.json file in the folder with the above content. VSCode may prompt you to install the Dev Container extension if you haven’t already, and/or to open the project in a container. If not, you can manually select “Dev Containers: Reopen in Container” from View &gt; Command Palette.\nIMPORTANT: If using this dev container configuration, you will need to set the DB_HOST environment variable to “host.docker.internal” in the .env file."
  },
  {
    "objectID": "docs/installation.html#install-development-dependencies-manually",
    "href": "docs/installation.html#install-development-dependencies-manually",
    "title": "Installation",
    "section": "Install development dependencies manually",
    "text": "Install development dependencies manually\n\nuv\nMacOS and Linux:\nwget -qO- https://astral.sh/uv/install.sh | sh\nWindows:\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\nSee the uv installation docs for more information.\n\n\nPython\nInstall Python 3.12 or higher from either the official downloads page or using uv:\n# Installs the latest version\nuv python install\n\n\nDocker and Docker Compose\nInstall Docker Desktop and Docker Compose for your operating system by following the instructions in the documentation.\n\n\nPostgreSQL headers\nFor Ubuntu/Debian:\nsudo apt update && sudo apt install -y python3-dev libpq-dev libwebp-dev\nFor macOS:\nbrew install postgresql\nFor Windows:\n\nNo installation required\n\n\n\nPython dependencies\nFrom the root directory, run:\nuv venv\nThis will create an in-project virtual environment. Then run:\nuv sync\nThis will install all dependencies.\n(Note: if psycopg2 installation fails, you probably just need to install the PostgreSQL headers first and then try again.)\n\n\nConfigure IDE\nIf you are using VSCode or Cursor as your IDE, you will need to select the uv-managed Python version as your interpreter for the project. Go to View &gt; Command Palette, search for Python: Select Interpreter, and select the Python version labeled ('.venv':venv).\nIt is also recommended to install the Python and Quarto IDE extensions."
  },
  {
    "objectID": "docs/installation.html#install-documentation-dependencies-manually",
    "href": "docs/installation.html#install-documentation-dependencies-manually",
    "title": "Installation",
    "section": "Install documentation dependencies manually",
    "text": "Install documentation dependencies manually\n\nQuarto CLI\nTo render the project documentation, you will need to download and install the Quarto CLI for your operating system.\n\n\nGraphviz\nArchitecture diagrams in the documentation are rendered with Graphviz.\nFor macOS:\nbrew install graphviz\nFor Ubuntu/Debian:\nsudo apt update && sudo apt install -y graphviz\nFor Windows:\n\nDownload and install from Graphviz.org"
  },
  {
    "objectID": "docs/installation.html#set-environment-variables",
    "href": "docs/installation.html#set-environment-variables",
    "title": "Installation",
    "section": "Set environment variables",
    "text": "Set environment variables\nCopy .env.example to .env with cp .env.example .env.\nGenerate a 256 bit secret key with openssl rand -base64 32 and paste it into the .env file.\nSet your desired database name, username, and password in the .env file.\nTo use password recovery, register a Resend account, verify a domain, get an API key, and paste the API key and sender email address into the .env file.\nIf using the dev container configuration, you will need to set the DB_HOST environment variable to “host.docker.internal” in the .env file. Otherwise, set DB_HOST to “localhost” for local development. (In production, DB_HOST will be set to the hostname of the database server.)"
  },
  {
    "objectID": "docs/installation.html#start-development-database",
    "href": "docs/installation.html#start-development-database",
    "title": "Installation",
    "section": "Start development database",
    "text": "Start development database\nTo start the development database, run the following command in your terminal from the root directory:\ndocker compose up -d\nIf at any point you change the environment variables in the .env file, you will need to stop the database service and tear down the volume:\n# Don't forget the -v flag to tear down the volume!\ndocker compose down -v\nYou may also need to restart the terminal session to pick up the new environment variables. You can also add the --force-recreate and --build flags to the startup command to ensure the container is rebuilt:\ndocker compose up -d --force-recreate --build"
  },
  {
    "objectID": "docs/installation.html#run-the-development-server",
    "href": "docs/installation.html#run-the-development-server",
    "title": "Installation",
    "section": "Run the development server",
    "text": "Run the development server\nBefore running the development server, make sure the development database is running and tables and default permissions/roles are created first. Then run the following command in your terminal from the root directory:\nuvicorn main:app --host 0.0.0.0 --port 8000 --reload\nNavigate to http://localhost:8000/.\n(Note: If startup fails with a sqlalchemy/psycopg2 connection error, make sure that Docker Desktop and the database service are running and that the environment variables in the .env file are correctly populated, and then try again.)"
  },
  {
    "objectID": "docs/installation.html#lint-types-with-mypy",
    "href": "docs/installation.html#lint-types-with-mypy",
    "title": "Installation",
    "section": "Lint types with mypy",
    "text": "Lint types with mypy\nmypy ."
  },
  {
    "objectID": "docs/authentication.html",
    "href": "docs/authentication.html",
    "title": "Authentication",
    "section": "",
    "text": "This template implements a comprehensive authentication system with security best practices:\n\nToken Security:\n\nJWT-based with separate access/refresh tokens\nStrict expiry times (30 min access, 30 day refresh)\nToken type validation\nHTTP-only cookies\nSecure flag enabled\nSameSite=strict restriction\n\nPassword Security:\n\nStrong password requirements enforced\nBcrypt hashing with random salt\nPassword reset tokens are single-use\nReset tokens have expiration\n\nCookie Security:\n\nHTTP-only prevents JavaScript access\nSecure flag ensures HTTPS only\nStrict SameSite prevents CSRF\n\nError Handling:\n\nValidation errors properly handled\nSecurity-related errors don’t leak information\nComprehensive error logging\n\n\nThe diagrams below show the main authentication flows."
  },
  {
    "objectID": "docs/authentication.html#security-features",
    "href": "docs/authentication.html#security-features",
    "title": "Authentication",
    "section": "",
    "text": "This template implements a comprehensive authentication system with security best practices:\n\nToken Security:\n\nJWT-based with separate access/refresh tokens\nStrict expiry times (30 min access, 30 day refresh)\nToken type validation\nHTTP-only cookies\nSecure flag enabled\nSameSite=strict restriction\n\nPassword Security:\n\nStrong password requirements enforced\nBcrypt hashing with random salt\nPassword reset tokens are single-use\nReset tokens have expiration\n\nCookie Security:\n\nHTTP-only prevents JavaScript access\nSecure flag ensures HTTPS only\nStrict SameSite prevents CSRF\n\nError Handling:\n\nValidation errors properly handled\nSecurity-related errors don’t leak information\nComprehensive error logging\n\n\nThe diagrams below show the main authentication flows."
  },
  {
    "objectID": "docs/authentication.html#registration-and-login-flow",
    "href": "docs/authentication.html#registration-and-login-flow",
    "title": "Authentication",
    "section": "Registration and login flow",
    "text": "Registration and login flow\n\n\n\nRegistration and login flow"
  },
  {
    "objectID": "docs/authentication.html#password-reset-flow",
    "href": "docs/authentication.html#password-reset-flow",
    "title": "Authentication",
    "section": "Password reset flow",
    "text": "Password reset flow\n\n\n\nPassword reset flow"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FastAPI, Jinja2, PostgreSQL Webapp Template",
    "section": "",
    "text": "Screenshot of homepage"
  },
  {
    "objectID": "index.html#quickstart",
    "href": "index.html#quickstart",
    "title": "FastAPI, Jinja2, PostgreSQL Webapp Template",
    "section": "Quickstart",
    "text": "Quickstart\nThis quickstart guide provides a high-level overview. See the full documentation for comprehensive information on features, installation, architecture, conventions, code style, and customization, deployment to cloud platforms, and contributing."
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "FastAPI, Jinja2, PostgreSQL Webapp Template",
    "section": "Features",
    "text": "Features\nThis template combines three of the most lightweight and performant open-source web development frameworks into a customizable webapp template with:\n\nPure Python backend\nMinimal-Javascript frontend\nPowerful, easy-to-manage database\n\nThe template also includes full-featured secure auth with:\n\nToken-based authentication\nPassword recovery flow\nRole-based access control system"
  },
  {
    "objectID": "index.html#design-philosophy",
    "href": "index.html#design-philosophy",
    "title": "FastAPI, Jinja2, PostgreSQL Webapp Template",
    "section": "Design Philosophy",
    "text": "Design Philosophy\nThe design philosophy of the template is to prefer low-level, best-in-class open-source frameworks that offer flexibility, scalability, and performance without vendor-lock-in. You’ll find the template amazingly easy not only to understand and customize, but also to deploy to any major cloud hosting platform."
  },
  {
    "objectID": "index.html#tech-stack",
    "href": "index.html#tech-stack",
    "title": "FastAPI, Jinja2, PostgreSQL Webapp Template",
    "section": "Tech Stack",
    "text": "Tech Stack\nCore frameworks:\n\nFastAPI: scalable, high-performance, type-annotated Python web backend framework\nPostgreSQL: the world’s most advanced open-source database engine\nJinja2: frontend HTML templating engine\nSQLModel: easy-to-use Python ORM\n\nAdditional technologies:\n\nuv: Python dependency manager\nPytest: testing framework\nDocker: development containerization\nGithub Actions: CI/CD pipeline\nQuarto: simple documentation website renderer\nMyPy: static type checker for Python\nBootstrap: HTML/CSS styler\nResend: zero- or low-cost email service used for password recovery"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "FastAPI, Jinja2, PostgreSQL Webapp Template",
    "section": "Installation",
    "text": "Installation\nFor comprehensive installation instructions, see the installation page.\n\nuv\nMacOS and Linux:\nwget -qO- https://astral.sh/uv/install.sh | sh\nWindows:\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\nSee the uv installation docs for more information.\n\n\nPython\nInstall Python 3.12 or higher from either the official downloads page or using uv:\n# Installs the latest version\nuv python install\n\n\nDocker and Docker Compose\nInstall Docker Desktop and Coker Compose for your operating system by following the instructions in the documentation.\n\n\nPostgreSQL headers\nFor Ubuntu/Debian:\nsudo apt update && sudo apt install -y python3-dev libpq-dev libwebp-dev\nFor macOS:\nbrew install postgresql\nFor Windows:\n\nNo installation required\n\n\n\nPython dependencies\nFrom the root directory, run:\nuv venv\nuv sync\nThis will create an in-project virtual environment and install all dependencies.\n\n\nSet environment variables\nCopy .env.example to .env with cp .env.example .env.\nGenerate a 256 bit secret key with openssl rand -base64 32 and paste it into the .env file.\nSet your desired database name, username, and password in the .env file.\nTo use password recovery and other email features, register a Resend account, verify a domain, get an API key, and paste the API key and the email address you want to send emails from into the .env file. Note that you will need to verify a domain through the Resend dashboard to send emails from that domain.\n\n\nStart development database\nTo start the development database, run the following command in your terminal from the root directory:\ndocker compose up -d\n\n\nRun the development server\nMake sure the development database is running and tables and default permissions/roles are created first.\nuv run python -m uvicorn main:app --host 0.0.0.0 --port 8000 --reload\nNavigate to http://localhost:8000/\n\n\nLint types with mypy\nuv run mypy ."
  },
  {
    "objectID": "index.html#developing-with-llms",
    "href": "index.html#developing-with-llms",
    "title": "FastAPI, Jinja2, PostgreSQL Webapp Template",
    "section": "Developing with LLMs",
    "text": "Developing with LLMs\nThe .cursor/rules folder contains a set of AI rules for working on this codebase in the Cursor IDE. We have also provided an llms.txt system prompt file for use with other agentic LLM workflows and exposed the full Markdown-formatted project documentation as a single text file for easy downloading and embedding for RAG."
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "FastAPI, Jinja2, PostgreSQL Webapp Template",
    "section": "Contributing",
    "text": "Contributing\nYour contributions are welcome! See the issues page for ideas. Fork the repository, create a new branch, make your changes, and submit a pull request."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "FastAPI, Jinja2, PostgreSQL Webapp Template",
    "section": "License",
    "text": "License\nThis project is created and maintained by Promptly Technologies, LLC and licensed under the MIT License. See the LICENSE file for more details."
  },
  {
    "objectID": "docs/contributing.html",
    "href": "docs/contributing.html",
    "title": "Contributing",
    "section": "",
    "text": "When opening a new issue or submitting a bug report, please include:\n\nA clear, descriptive title\nFor bug reports:\n\nDescription of the expected behavior\nDescription of the actual behavior\nSteps to reproduce the issue\nVersion information (OS, Python version, package version)\nAny relevant error messages or screenshots\n\nFor feature requests:\n\nDescription of the proposed feature\nUse case or motivation for the feature\nAny implementation suggestions (optional)\n\n\nLabels help categorize issues: - Use bug for reporting problems - Use enhancement for feature requests - Use documentation for documentation improvements - Use question for general queries\n\n\n\nTo contribute code to the project:\n\nFork the repository and clone your fork locally\nCreate a new branch from main with a descriptive name\nReview the customization, architecture, and authentication pages for guidance on design patterns and code structure and style\nEnsure all tests pass, including mypy type checking\nStage, commit, and push your changes to the branch:\n\nUse clear, descriptive commit messages\nKeep commits focused and atomic\n\nSubmit your pull request:\n\nProvide a clear description of the changes\nLink to any related issues\n\n\n\n\n\nThe README and documentation website are rendered with Quarto. If you make changes to the .qmd files in the root folder and the docs folder, you will need to re-render the docs with Quarto.\nQuarto expects environment variables to be set in a file called _environment, so before running Quarto render commands, you should copy your .env file to _environment.\n# To copy the .env file to _environment\ncp .env _environment\n# To render the documentation website\nuv run quarto render\n# To render the README\nuv run quarto render index.qmd --output-dir . --output README.md --to gfm\nDue to a quirk of Quarto, an unnecessary index.html file is created in the root folder when the README is rendered. This file can be safely deleted.\nNote that even if your pull request is merged, your changes will not be reflected on the live website until a maintainer republishes the docs."
  },
  {
    "objectID": "docs/contributing.html#contributors",
    "href": "docs/contributing.html#contributors",
    "title": "Contributing",
    "section": "",
    "text": "When opening a new issue or submitting a bug report, please include:\n\nA clear, descriptive title\nFor bug reports:\n\nDescription of the expected behavior\nDescription of the actual behavior\nSteps to reproduce the issue\nVersion information (OS, Python version, package version)\nAny relevant error messages or screenshots\n\nFor feature requests:\n\nDescription of the proposed feature\nUse case or motivation for the feature\nAny implementation suggestions (optional)\n\n\nLabels help categorize issues: - Use bug for reporting problems - Use enhancement for feature requests - Use documentation for documentation improvements - Use question for general queries\n\n\n\nTo contribute code to the project:\n\nFork the repository and clone your fork locally\nCreate a new branch from main with a descriptive name\nReview the customization, architecture, and authentication pages for guidance on design patterns and code structure and style\nEnsure all tests pass, including mypy type checking\nStage, commit, and push your changes to the branch:\n\nUse clear, descriptive commit messages\nKeep commits focused and atomic\n\nSubmit your pull request:\n\nProvide a clear description of the changes\nLink to any related issues\n\n\n\n\n\nThe README and documentation website are rendered with Quarto. If you make changes to the .qmd files in the root folder and the docs folder, you will need to re-render the docs with Quarto.\nQuarto expects environment variables to be set in a file called _environment, so before running Quarto render commands, you should copy your .env file to _environment.\n# To copy the .env file to _environment\ncp .env _environment\n# To render the documentation website\nuv run quarto render\n# To render the README\nuv run quarto render index.qmd --output-dir . --output README.md --to gfm\nDue to a quirk of Quarto, an unnecessary index.html file is created in the root folder when the README is rendered. This file can be safely deleted.\nNote that even if your pull request is merged, your changes will not be reflected on the live website until a maintainer republishes the docs."
  },
  {
    "objectID": "docs/contributing.html#maintainers",
    "href": "docs/contributing.html#maintainers",
    "title": "Contributing",
    "section": "Maintainers",
    "text": "Maintainers\n\nGit flow\nWhen creating new features,\n\nOpen a Github issue with the label feature and assign it to yourself.\nCreate a new branch from the issue sidebar.\nFollow the instructions in the popup to check out the branch locally and make your changes on the branch.\nCommit your changes and push to the branch.\nWhen you are ready to merge, open a pull request from the branch to main.\nAssign someone else for code review.\n\n\n\nPublishing the documentation\nTo publish the documentation to GitHub Pages, run the following command:\nuv run quarto publish gh-pages"
  },
  {
    "objectID": "docs/deployment.html",
    "href": "docs/deployment.html",
    "title": "Deployment",
    "section": "",
    "text": "This application requires two services to be deployed and connected to each other:\nThere are many hosting options available for each of these services; this guide will cover only a few of them."
  },
  {
    "objectID": "docs/deployment.html#deploying-and-configuring-the-postgresql-database",
    "href": "docs/deployment.html#deploying-and-configuring-the-postgresql-database",
    "title": "Deployment",
    "section": "Deploying and Configuring the PostgreSQL Database",
    "text": "Deploying and Configuring the PostgreSQL Database\n\nOn Digital Ocean\n\nGetting Started\n\nCreate a DigitalOcean account\nInstall the doctl CLI tool and authenticate with doctl auth init\nInstall the psql client\n\n\n\nCreate a Project\nCreate a new project to organize your resources:\n# List existing projects\ndoctl projects list\n\n# Create a new project\ndoctl projects create --name \"YOUR-PROJECT-NAME\" --purpose \"YOUR-PROJECT-PURPOSE\" --environment \"Production\"\n\n\nSet Up a Managed PostgreSQL Database\nCreate a managed, serverless PostgreSQL database instance:\ndoctl databases create your-db-name --engine pg --version 17 --size db-s-1vcpu-1gb --num-nodes 1 --wait\nGet the database ID from the output of the create command and use it to retrieve the database connection details:\n# Get the database connection details\ndoctl databases connection \"your-database-id\" --format Host,Port,User,Password,Database\nStore these details securely in a .env.production file (you will need to set them later in application deployment as production secrets):\n# Database connection parameters\nDB_HOST=your-host\nDB_PORT=your-port\nDB_USER=your-user\nDB_PASS=your-password\nDB_NAME=your-database\nYou may also want to save your database id, although you can always find it again later by listing your databases with doctl databases list.\n\n\nSetting Up a Firewall Rule (after Deploying Your Application Layer)\nNote that by default your database is publicly accessible from the Internet, so you should create a firewall rule to restrict access to only your application’s IP address once you have deployed the application. The command to do this is:\ndoctl databases firewalls append &lt;database-cluster-id&gt; --rule &lt;type&gt;:&lt;value&gt;\nwhere &lt;type&gt; is ip_addr and &lt;value&gt; is the IP address of the application server. See the DigitalOcean documentation for more details.\nNote: You can only complete this step after you have deployed your application layer and obtained a static IP address for the application server."
  },
  {
    "objectID": "docs/deployment.html#deploying-and-configuring-the-fastapi-app",
    "href": "docs/deployment.html#deploying-and-configuring-the-fastapi-app",
    "title": "Deployment",
    "section": "Deploying and Configuring the FastAPI App",
    "text": "Deploying and Configuring the FastAPI App\n\nOn Modal.com\nThe big advantages of deploying on Modal.com are: 1. that they offer $30/month of free credits for each user, plus generous additional free credit allotments for startups and researchers, and 2. that it’s a very user-friendly platform.\nThe disadvantages are: 1. that Modal is a Python-only platform and cannot run the database layer, so you’ll have to deploy that somewhere else, 2. that you’ll need to make some modest changes to the codebase to get it to work on Modal, and 3. that Modal offers a static IP address for the application server only if you pay for a higher-tier plan starting at $250/year, which makes securing the database layer with a firewall rule cost prohibitive.\n\nGetting Started\n\nSign up for a Modal.com account\nInstall modal in the project directory with uv add modal\nRun uv run modal setup to authenticate with Modal\n\n\n\nDefining the Modal Image and App\nCreate a new Python file in the root of your project, for example, deploy.py. This file will define the Modal Image and the ASGI app deployment.\n\nDefine the Modal Image in deploy.py:\n\nUse modal.Image to define the container environment. Chain methods to install dependencies and add code/files.\nStart with a Debian base image matching your Python version (e.g., 3.13).\nInstall necessary system packages (libpq-dev for psycopg2, libwebp-dev for Pillow WebP support).\nInstall Python dependencies using run_commands with uv.\nAdd your local Python modules (routers, utils, exceptions) using add_local_python_source.\nAdd the static and templates directories using add_local_dir. The default behaviour (copying on container startup) is usually fine for development, but consider copy=True for production stability if these files are large or rarely change.\n\n# deploy.py\nimport modal\nimport os\n\n# Define the base image\nimage = (\n    modal.Image.debian_slim(python_version=\"3.13\")\n    .apt_install(\"libpq-dev\", \"libwebp-dev\")\n    .pip_install_from_pyproject(\"pyproject.toml\")\n    .add_local_python_source(\"main\")\n    .add_local_python_source(\"routers\")\n    .add_local_python_source(\"utils\")\n    .add_local_python_source(\"exceptions\")\n    .add_local_dir(\"static\", remote_path=\"/root/static\")\n    .add_local_dir(\"templates\", remote_path=\"/root/templates\")\n)\n\n# Define the Modal App\napp = modal.App(\n    name=\"your-app-name\",\n    image=image,\n    secrets=[modal.Secret.from_name(\"your-app-name-secret\")]\n)\nDefine the ASGI App Function in deploy.py:\n\nCreate a function decorated with @app.function() and @modal.asgi_app().\nInside this function, import your FastAPI application instance from main.py.\nReturn the FastAPI app instance.\nUse @modal.concurrent() to allow the container to handle multiple requests concurrently.\n\n# deploy.py (continued)\n\n# Define the ASGI app function\n@app.function(\n    allow_concurrent_inputs=100 # Adjust concurrency as needed\n)\n@modal.asgi_app()\ndef fastapi_app():\n    # Important: Import the app *inside* the function\n    # This ensures it runs within the Modal container environment\n    # and has access to the installed packages and secrets.\n    # It also ensures the lifespan function (db setup) runs correctly\n    # with the environment variables provided by the Modal Secret.\n    from main import app as web_app\n\n    return web_app\n\nFor more information on Modal FastAPI images and applications, see this guide.\n\n\nDeploying the App\nFrom your terminal, in the root directory of your project, run:\nmodal deploy deploy.py\nModal will build the image (if it hasn’t been built before or if dependencies changed) and deploy the ASGI app. It will output a public URL (e.g., https://your-username--your-app-name.modal.run).\n\n\nSetting Up Modal Secrets\nThe application relies on environment variables stored in .env (like SECRET_KEY, DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME, RESEND_API_KEY, BASE_URL). These sensitive values should be stored securely using Modal Secrets.\nCreate a Modal Secret either through the Modal UI or CLI. Note that the name of the secret has to match the secret name you used in the deploy.py file, above (e.g., your-app-name-secret).\n# Example using CLI\nmodal secret create your-app-name-secret \\\n    SECRET_KEY='your_actual_secret_key' \\\n    DB_USER='your_db_user' \\\n    DB_PASSWORD='your_db_password' \\\n    DB_HOST='your_external_db_host' \\\n    DB_PORT='your_db_port' \\\n    DB_NAME='your_db_name' \\\n    RESEND_API_KEY='your_resend_api_key' \\\n    BASE_URL='https://your-username--your-app-name-serve.modal.run'\nImportant: Ensure DB_HOST points to your cloud database host address, not localhost or host.docker.internal.\n\n\nTesting the Deployment\nAccess the provided Modal URL in your browser. Browse the site and test the registration and password reset features to ensure database and Resend connections work."
  },
  {
    "objectID": "docs/customization.html",
    "href": "docs/customization.html",
    "title": "Customization",
    "section": "",
    "text": "The project uses uv to manage dependencies:\n\nAdd new dependency: uv add &lt;dependency&gt;\nAdd development dependency: uv add --dev &lt;dependency&gt;\nRemove dependency: uv remove &lt;dependency&gt;\nUpdate lock file: uv lock\nInstall all dependencies: uv sync\nInstall only production dependencies: uv sync --no-dev\nUpgrade dependencies: uv lock --upgrade\n\n\n\n\nIf you are using VSCode or Cursor as your IDE, you will need to select the uv-managed Python version as your interpreter for the project. Go to View &gt; Command Palette, search for Python: Select Interpreter, and select the Python version labeled ('.venv':venv).\nIf your IDE does not automatically detect and display this option, you can manually select the interpreter by selecting “Enter interpreter path” and then navigating to the .venv/bin/python subfolder in your project directory.\n\n\n\nThe routers/core/ and utils/core/ directories contain the core backend logic for the template.\nYour custom Python backend code should go primarily in the routers/app/ and utils/app/ directories.\nFor the frontend, you will also need to develop custom Jinja2 templates in the templates/ folder and add custom static assets in static/.\n\n\n\nThe project uses Pytest for unit testing. It’s highly recommended to write and run tests before committing code to ensure nothing is broken!\nThe following fixtures, defined in tests/conftest.py, are available in the test suite:\n\nengine: Creates a new SQLModel engine for the test database.\nset_up_database: Sets up the test database before running the test suite by dropping all tables and recreating them to ensure a clean state.\nsession: Provides a session for database operations in tests.\nclean_db: Cleans up the database tables before each test by deleting all entries in the PasswordResetToken, EmailUpdateToken, User, Role, Organization, and Account tables.\ntest_account: Creates a test account with a predefined email and hashed password.\ntest_user: Creates a test user in the database linked to the test account.\nauth_client: Provides a TestClient instance with access and refresh token cookies set, overriding the get_session dependency to use the session fixture.\nunauth_client: Provides a TestClient instance without authentication cookies set, overriding the get_session dependency to use the session fixture.\ntest_organization: Creates a test organization for use in tests.\n\nTo run the tests, use these commands:\n\nRun all tests: uv run pytest\nRun tests in debug mode (includes logs and print statements in console output): uv run pytest -s\nRun particular test files by name: uv run pytest &lt;test_file_name&gt;\nRun particular tests by name: uv run pytest -k &lt;test_name&gt;\n\n\n\n\nThe project uses type annotations and mypy for static type checking. To run mypy, use this command from the root directory:\nmypy .\nWe find that mypy is an enormous time-saver, catching many errors early and greatly reducing time spent debugging unit tests. However, note that mypy requires you type annotate every variable, function, and method in your code base, so taking advantage of it requires a lifestyle change!\n\n\n\nThe .cursor/rules folder contains a set of AI rules for working on this codebase in the Cursor IDE. We have also provided an llms.txt system prompt file for use with other agentic LLM workflows and exposed the full Markdown-formatted project documentation as a single text file for easy downloading and embedding for RAG."
  },
  {
    "objectID": "docs/customization.html#development-workflow",
    "href": "docs/customization.html#development-workflow",
    "title": "Customization",
    "section": "",
    "text": "The project uses uv to manage dependencies:\n\nAdd new dependency: uv add &lt;dependency&gt;\nAdd development dependency: uv add --dev &lt;dependency&gt;\nRemove dependency: uv remove &lt;dependency&gt;\nUpdate lock file: uv lock\nInstall all dependencies: uv sync\nInstall only production dependencies: uv sync --no-dev\nUpgrade dependencies: uv lock --upgrade\n\n\n\n\nIf you are using VSCode or Cursor as your IDE, you will need to select the uv-managed Python version as your interpreter for the project. Go to View &gt; Command Palette, search for Python: Select Interpreter, and select the Python version labeled ('.venv':venv).\nIf your IDE does not automatically detect and display this option, you can manually select the interpreter by selecting “Enter interpreter path” and then navigating to the .venv/bin/python subfolder in your project directory.\n\n\n\nThe routers/core/ and utils/core/ directories contain the core backend logic for the template.\nYour custom Python backend code should go primarily in the routers/app/ and utils/app/ directories.\nFor the frontend, you will also need to develop custom Jinja2 templates in the templates/ folder and add custom static assets in static/.\n\n\n\nThe project uses Pytest for unit testing. It’s highly recommended to write and run tests before committing code to ensure nothing is broken!\nThe following fixtures, defined in tests/conftest.py, are available in the test suite:\n\nengine: Creates a new SQLModel engine for the test database.\nset_up_database: Sets up the test database before running the test suite by dropping all tables and recreating them to ensure a clean state.\nsession: Provides a session for database operations in tests.\nclean_db: Cleans up the database tables before each test by deleting all entries in the PasswordResetToken, EmailUpdateToken, User, Role, Organization, and Account tables.\ntest_account: Creates a test account with a predefined email and hashed password.\ntest_user: Creates a test user in the database linked to the test account.\nauth_client: Provides a TestClient instance with access and refresh token cookies set, overriding the get_session dependency to use the session fixture.\nunauth_client: Provides a TestClient instance without authentication cookies set, overriding the get_session dependency to use the session fixture.\ntest_organization: Creates a test organization for use in tests.\n\nTo run the tests, use these commands:\n\nRun all tests: uv run pytest\nRun tests in debug mode (includes logs and print statements in console output): uv run pytest -s\nRun particular test files by name: uv run pytest &lt;test_file_name&gt;\nRun particular tests by name: uv run pytest -k &lt;test_name&gt;\n\n\n\n\nThe project uses type annotations and mypy for static type checking. To run mypy, use this command from the root directory:\nmypy .\nWe find that mypy is an enormous time-saver, catching many errors early and greatly reducing time spent debugging unit tests. However, note that mypy requires you type annotate every variable, function, and method in your code base, so taking advantage of it requires a lifestyle change!\n\n\n\nThe .cursor/rules folder contains a set of AI rules for working on this codebase in the Cursor IDE. We have also provided an llms.txt system prompt file for use with other agentic LLM workflows and exposed the full Markdown-formatted project documentation as a single text file for easy downloading and embedding for RAG."
  },
  {
    "objectID": "docs/customization.html#application-architecture",
    "href": "docs/customization.html#application-architecture",
    "title": "Customization",
    "section": "Application architecture",
    "text": "Application architecture\n\nPost-Redirect-Get pattern\nIn this template, we use FastAPI to define the “API endpoints” of our application. An API endpoint is simply a URL that accepts user requests and returns responses. When a user visits a page, their browser sends what’s called a “GET” request to an endpoint, and the server processes it (often querying a database), and returns a response (typically HTML). The browser renders the HTML, displaying the page.\nWe also create POST endpoints, which accept form submissions so the user can create, update, and delete data in the database. This template follows the Post-Redirect-Get (PRG) pattern to handle POST requests. When a form is submitted, the server processes the data and then returns a “redirect” response, which sends the user to a GET endpoint to re-render the page with the updated data. (See Architecture for more details.)\n\nFile structure\n\nFastAPI application entry point and homepage GET route: main.py\nTemplate FastAPI routes: routers/core/\n\nAccount and authentication endpoints: account.py\nUser profile management endpoints: user.py\nOrganization management endpoints: organization.py\nRole management endpoints: role.py\nDashboard page: dashboard.py\nStatic pages (e.g., about, privacy policy, terms of service): static_pages.py\n\nCustom FastAPI routes for your app: routers/app/\nJinja2 templates: templates/\nStatic assets: static/\nUnit tests: tests/\nTest database configuration: docker-compose.yml\nTemplate helper functions: utils/core/\n\nAuth helpers: auth.py\nDatabase helpers: db.py\nFastAPI dependencies: dependencies.py\nEnums: enums.py\nImage helpers: images.py\nDatabase models: models.py\n\nCustom template helper functions for your app: utils/app/\nExceptions: exceptions/\n\nHTTP exceptions: http_exceptions.py\nOther custom exceptions: exceptions.py\n\nEnvironment variables: .env.example, .env\nCI/CD configuration: .github/\nProject configuration: pyproject.toml\nQuarto documentation:\n\nREADME source: index.qmd\nWebsite source: index.qmd + docs/\nConfiguration: _quarto.yml + _environment\n\nRules for developing with LLMs in Cursor IDE: .cursor/rules/\n\nMost everything else is auto-generated and should not be manually modified."
  },
  {
    "objectID": "docs/customization.html#backend",
    "href": "docs/customization.html#backend",
    "title": "Customization",
    "section": "Backend",
    "text": "Backend\n\nCode conventions\nThe GET route for the homepage is defined in the main entry point for the application, main.py. The entrypoint imports router modules from the routers/core/ directory (for core/template logic) and routers/app/ directory (for app-specific logic). In CRUD style, the core router modules are named after the resource they manage, e.g., account.py for account management. You should place your own endpoints in routers/app/.\nWe name our GET routes using the convention read_&lt;name&gt;, where &lt;name&gt; is the name of the resource, to indicate that they are read-only endpoints that do not modify the database. In POST routes that modify the database, you can use the get_session dependency as an argument to get a database session.\nRoutes that require authentication generally take the get_authenticated_account dependency as an argument. Unauthenticated GET routes generally take the get_optional_user dependency as an argument. If a route should only be seen by authenticated users (i.e., a login page), you can redirect to the dashboard if get_optional_user returns a User object.\n\n\nContext variables\nContext refers to Python variables passed to a template to populate the HTML. In a FastAPI GET route, we can pass context to a template using the templates.TemplateResponse method, which takes the request and any context data as arguments. For example:\n@app.get(\"/welcome\")\nasync def welcome(request: Request):\n    return templates.TemplateResponse(\n        request,\n        \"welcome.html\",\n        {\"username\": \"Alice\"}\n    )\nIn this example, the welcome.html template will receive two pieces of context: the user’s request, which is always passed automatically by FastAPI, and a username variable, which we specify as “Alice”. We can then use the {{ username }} syntax in the welcome.html template (or any of its parent or child templates) to insert the value into the HTML.\n\n\nEmail templating\nPassword reset and other transactional emails are also handled through Jinja2 templates, located in the templates/emails directory. The email templates follow the same inheritance pattern as web templates, with base_email.html providing the common layout and styling.\nHere’s how the default password reset email template looks:\n\n\n\nDefault Password Reset Email Template\n\n\nThe email templates use inline CSS styles to ensure consistent rendering across email clients. Like web templates, they can receive context variables from the Python code (such as reset_url in the password reset template).\n\n\nServer-side form validation\nPydantic is used for data validation and serialization. It ensures that the data received in requests meets the expected format and constraints. Pydantic models are used to define the structure of request and response data, making it easy to validate and parse JSON payloads.\nIf a user-submitted form contains data that has the wrong number, names, or types of fields, Pydantic will raise a RequestValidationError, which is caught by middleware and converted into an HTTP 422 error response.\n\n\nMiddleware exception handling\nMiddlewares—which process requests before they reach the route handlers and responses before they are sent back to the client—are defined in main.py. They are commonly used in web development for tasks such as error handling, authentication token validation, logging, and modifying request/response objects.\nThis template uses middlewares exclusively for global exception handling; they only affect requests that raise an exception. This allows for consistent error responses and centralized error logging. Middleware can catch exceptions raised during request processing and return appropriate HTTP responses.\nMiddleware functions are decorated with @app.exception_handler(ExceptionType) and are executed in the order they are defined in main.py, from most to least specific.\nHere’s a middleware for handling the PasswordMismatchError exception from the previous example, which renders the errors/validation_error.html template with the error details:\n@app.exception_handler(PasswordValidationError)\nasync def password_validation_exception_handler(request: Request, exc: PasswordValidationError):\n    return templates.TemplateResponse(\n        request,\n        \"errors/validation_error.html\",\n        {\n            \"status_code\": 422,\n            \"errors\": {\"error\": exc.detail}\n        },\n        status_code=422,\n    )"
  },
  {
    "objectID": "docs/customization.html#database-configuration-and-access-with-sqlmodel",
    "href": "docs/customization.html#database-configuration-and-access-with-sqlmodel",
    "title": "Customization",
    "section": "Database configuration and access with SQLModel",
    "text": "Database configuration and access with SQLModel\nSQLModel is an Object-Relational Mapping (ORM) library that allows us to interact with our PostgreSQL database using Python classes instead of writing raw SQL. It combines the features of SQLAlchemy (a powerful database toolkit) with Pydantic’s data validation.\n\nModels and relationships\nCore database models are defined in utils/core/models.py. Each model is a Python class that inherits from SQLModel and represents a database table. The key core models are:\n\nAccount: Represents a user account with email and password hash\nUser: Represents a user profile with details like name and avatar; the email and password hash are stored in the related Account model\nOrganization: Represents a company or team\nRole: Represents a set of permissions within an organization\nPermission: Represents specific actions a user can perform (defined by ValidPermissions enum)\nPasswordResetToken: Manages password reset functionality with expiration\nEmailUpdateToken: Manages email update confirmation functionality with expiration\n\nTwo additional models are used by SQLModel to manage many-to-many relationships; you generally will not need to interact with them directly:\n\nUserRoleLink: Maps users to their roles (many-to-many relationship)\nRolePermissionLink: Maps roles to their permissions (many-to-many relationship)\n\nHere’s an entity-relationship diagram (ERD) of the current core database schema, automatically generated from our SQLModel definitions:\n\n\n\nDatabase Schema\n\n\nTo extend the database schema, define your own models in utils/app/models.py and import them in utils/core/db.py to make sure they are included in the metadata object in the create_all function.\n\n\nDatabase helpers\nDatabase operations are facilitated by helper functions in utils/core/db.py (for core logic) and utils/app/ (for app-specific helpers). Key functions in the core utils include:\n\nset_up_db(): Initializes the database schema and default data (which we do on every application start in main.py)\nget_connection_url(): Creates a database connection URL from environment variables in .env\nget_session(): Provides a database session for performing operations\n\nTo perform database operations in route handlers, inject the database session as a dependency (from utils/core/db.py):\n@app.get(\"/users\")\nasync def get_users(session: Session = Depends(get_session)):\n    users = session.exec(select(User)).all()\n    return users\nThe session automatically handles transaction management, ensuring that database operations are atomic and consistent.\nThere is also a helper method on the User model that checks if a user has a specific permission for a given organization. Its first argument must be a ValidPermissions enum value (from utils/core/models.py), and its second argument must be an Organization object or an int representing an organization ID:\npermission = ValidPermissions.CREATE_ROLE\norganization = session.exec(select(Organization).where(Organization.name == \"Acme Inc.\")).first()\n\nuser.has_permission(permission, organization)\nYou should create custom AppPermissions enum values for your application in utils/app/ (if needed) and validate that users have the necessary permissions before allowing them to modify organization data resources.\n\n\nCascade deletes\nCascade deletes (in which deleting a record from one table deletes related records from another table) can be handled at either the ORM level or the database level. This template handles cascade deletes at the ORM level, via SQLModel relationships. Inside a SQLModel Relationship, we set:\nsa_relationship_kwargs={\n    \"cascade\": \"all, delete-orphan\"\n}\nThis tells SQLAlchemy to cascade all operations (e.g., SELECT, INSERT, UPDATE, DELETE) to the related table. Since this happens through the ORM, we need to be careful to do all our database operations through the ORM using supported syntax. That generally means loading database records into Python objects and then deleting those objects rather than deleting records in the database directly.\nFor example,\nsession.exec(delete(Role))\nwill not trigger the cascade delete. Instead, we need to select the role objects and then delete them:\nfor role in session.exec(select(Role)).all():\n    session.delete(role)\nThis is slower than deleting the records directly, but it makes many-to-many relationships much easier to manage."
  },
  {
    "objectID": "docs/customization.html#frontend",
    "href": "docs/customization.html#frontend",
    "title": "Customization",
    "section": "Frontend",
    "text": "Frontend\n\nHTML templating with Jinja2\nTo generate the HTML pages to be returned from our GET routes, we use Jinja2 templates. Jinja2’s hierarchical templates allow creating a base template (templates/base.html) that defines the overall layout of our web pages (e.g., where the header, body, and footer should go). Individual pages can then extend this base template. We can also template reusable components that can be injected into our layout or page templates.\nWith Jinja2, we can use the {% block %} tag to define content blocks, and the {% extends %} tag to extend a base template. We can also use the {% include %} tag to include a component in a parent template. See the Jinja2 documentation on template inheritance for more details.\n\n\nCustom theming with Bootstrap\nInstall Node.js on your local machine if it is not there already.\nInstall bootstrap, sass, gulp, and gulp-sass in your project:\nnpm install --save-dev bootstrap sass gulp gulp-cli gulp-sass\nThis will create a node_modules folder, a package-lock.json file, and a package.json file in the root directory of the project.\nCreate an scss folder and a basic scss/styles.scss file:\nmkdir scss\ntouch scss/styles.scss\nYour custom styles will go in scss/styles.scss, along with @import statements to include the Bootstrap components you want.\n\nCustomizing the Bootstrap SCSS\nThe default CSS for the template was compiled from the following scss/styles.scss configuration, which imports all of Bootstrap and overrides the $theme-colors and $font-family-base variables:\n// styles.scss\n\n// Include any default variable overrides here (functions won't be available)\n\n// State colors\n$primary: #7464a1;\n$secondary: #64a19d;\n$success: #67c29c;\n$info: #1cabc4;\n$warning: #e4c662;\n$danger: #a16468;\n$light: #f8f9fa;\n$dark: #343a40;\n\n// Bootstrap color map\n$theme-colors: (\n    \"primary\": $primary,\n    \"secondary\": $secondary,\n    \"success\": $success,\n    \"info\": $info,\n    \"warning\": $warning,\n    \"danger\": $danger,\n    \"light\": $light,\n    \"dark\": $dark\n);\n\n$font-family-base: (\n    \"Nunito\",\n    -apple-system,\n    BlinkMacSystemFont,\n    \"Segoe UI\",\n    Roboto,\n    \"Helvetica Neue\",\n    Arial,\n    sans-serif,\n    \"Apple Color Emoji\",\n    \"Segoe UI Emoji\",\n    \"Segoe UI Symbol\",\n    \"Noto Color Emoji\"\n);\n\n// Include all of Bootstrap\n\n@import \"../node_modules/bootstrap/scss/bootstrap\";\nThe most common use case for styles.scss is to define a custom color scheme and fonts, but it’s also possible to customize some other visual details such as border radius and box shadow depth. See the Bootstrap Sass customization documentation and the many free templates available at Start Bootstrap for examples.\n\n\nCompiling the SCSS to CSS\nTo compile the SCSS files to CSS, we use gulp. In the project root directory, create a gulpfile.js file with the following content:\n   const gulp = require('gulp');\n   const sass = require('gulp-sass')(require('sass'));\n\n   // Define a task to compile Sass\n   gulp.task('sass', function() {\n       return gulp.src('scss/**/*.scss') // Source folder containing Sass files\n           .pipe(sass().on('error', sass.logError))\n           .pipe(gulp.dest('static/css')); // Destination folder for compiled CSS\n   });\n\n   // Define a default task\n   gulp.task('default', gulp.series('sass'));\nTo compile the SCSS file to static/css, run this command:\nnpx gulp\nNote that this will overwrite the existing static/css/styles.css file, so if you want to define any custom CSS styles, you should do so in either the scss/styles.scss file or in static/css/extras.css.\n\n\n\nClient-side form validation\nWhile this template includes comprehensive server-side validation through Pydantic models and custom validators, it’s important to note that server-side validation should be treated as a fallback security measure. If users ever see the validation_error.html template, it indicates that our client-side validation has failed to catch invalid input before it reaches the server.\nBest practices dictate implementing thorough client-side validation via JavaScript and/or HTML input element pattern attributes to:\n\nProvide immediate feedback to users\nReduce server load\nImprove user experience by avoiding round-trips to the server\nPrevent malformed data from ever reaching the backend\n\nServer-side validation remains essential as a security measure against malicious requests that bypass client-side validation, but it should rarely be encountered during normal user interaction. See templates/authentication/register.html for a client-side form validation example involving both JavaScript and HTML regex pattern matching."
  }
]